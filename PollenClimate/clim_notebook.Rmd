---
title: "Pollen-based Climate Reconstruction"
author: 'Simon Goring'
output: 
  html_document:
    theme: journal
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
    code_folding: show

---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)
library(dplyr, quietly = TRUE)
library(ggplot2)
suppressMessages(library(palaeoSig, quietly = TRUE))
suppressMessages(library(rioja, quietly = TRUE))
suppressMessages(library(analogue, quietly = TRUE))
suppressMessages(library(neotoma, quietly = TRUE))
```

# Model Diagnostics

```{r load_files, echo = FALSE, warning=FALSE}

# Load all the files & cross-check:

data(Pollen)   # Adds the pollen from analogue.
data(Climate)  # Adds associated climate.

# There's currently a bug in the `analogue` package.
colnames(Climate)[1:3] <- c('tjan', 'tfeb', 'tmar')

data(Location)

```

The Modern Pollen Database stored in `analogue` contains `r nrow(Pollen)` samples, representing `r ncol(Pollen)` different pollen taxa.

## Checking the Transfer Functions

### Checking the calibration data set

To test the models I used the `palaeoSig` package's `randomTS()` function, which tests the models against randomly sorted data.  Significance for any climate variable indicates that the model reconstruction is better than random numbers.  In each case I use 70% of the training set, rather than the full training set.  The model takes the proportion of variance accounted for by the actual data, and then compares it to the proportion of variance accounted for by the randomized data.  This is then done for each of the different methods used for calibration.

In each case these methods are simply testing whether the modern calibration is able to detect signals in each of the climate parameters.  The example here uses the entire North American Modern Pollen Database, rather than a targeted data subset.  It also uses the climate variables provided with the dataset.  For a given research application it may be better to specifically choose a particular climate variable (or climate subset) or obtain new climatic data from a more recent downscaled climate data product, for example WorldClim or PRISM.

##### WA - Monotone Deshrinking

```{r WA_SigTesting_pine, cache=TRUE, results='asis', echo=FALSE, warning=FALSE}

# This is a wrapper for the randomTF function.
source('R/sig_test.R')

wa_sig <- run_tf(pollen = Pollen, 
                 climate = Climate[,1:ncol(Climate)], 
                 func = WA, col = 1, mono = TRUE)

wa_sig[[1]]
```

Weighted Averaging results using monotone deshrinking on subsets of the pollen data indicate that there is significance in reconstructions of most temperature parameters, while precipitation variables are not significant.  While temperature variables are significant, this relatively naive approach indicates that there is a relatively low proportion of variance explained by the temperature reconstructions.

##### WAPLS (Four components)

```{r WAPLS_sigtesting_Pine, cache=TRUE, results='asis', echo=FALSE, warning=FALSE}

wapls_sig <- run_tf(pollen = Pollen, 
                    climate = Climate[,1:ncol(Climate)], 
                    func = WAPLS, col = 3) 

wapls_sig[[1]]

```

For WAPLS all models show significance, but explain very little of the overall variance.  We probably shouldn't use WAPLS given this assessment.

##### MAT - ten closest

```{r MAT_sigtesting_Pine, cache=TRUE, results='asis', echo=FALSE, warning=FALSE}

# For some reason this fails consistently when we try to use the weighted MAT (col=2).
mat_sig <- run_tf(pollen = Pollen, 
                  climate = Climate[,1:ncol(Climate)], 
                  func = MAT, col = 1, k = 10)
mat_sig[[1]]

```

Again, significance for all parameters, but very little variance explained.

# Reconstruction Statistics

## Reconstruction Significance

Now we test to see which of the fossil assemblage reconstructions show significant changes over the course of the reconstruction.  This uses the same `randomTF()` function, but the degree of variance and significance is likely to change given that the test dataset, in this case Orhid, has changed and has a much more constrained ecological space than the entire European Modern Pollen Database.

### Obtaining a record from Neotoma

Then we apply a reconstruction to a real dataset.  In this case we will select a record with coverage across multiple timescales.  For the sake of this example, we'll restrict the analysis to a record from Canada.

```{r}
can_sites <- neotoma::get_dataset(ageold = 12000, 
                                  ageyoung = -50, 
                                  gpid = 'Canada',
                                  datasettype = 'pollen')

```
This returns `r length(can_sites)` sites.  The `neotoma` package provides plotting capabilities, but they are rudimentary.  To provide interactive plotting we plot the sites dynamically using `leaflet`.  This isn't something you need to do, but it does help showcase the flexibility of R:

```{r}

library(leaflet)

datasets <- sapply(can_sites, function(x) x$dataset.meta$dataset.id)

map <- leaflet(width = 400, height = 400) %>% 
  addTiles %>% 
  setView(lng = -100,
          lat = 49.263,
          zoom = 3)

locations <- can_sites %>% get_site

map %>% addMarkers(lng = locations$long, lat = locations$lat, 
                   popup = paste0('<b>', as.character(~site.name), '</b><br>',
                                  '<a href=http://apps.neotomadb.org/explorer/?datasetid=', datasets, '>Explorer Link</a>'))

```


#### WA - Monotone Deshrinking

```{r WA_SigTesting, cache=TRUE, results='asis', echo=FALSE, warning=FALSE}

fossil_data <- get_download(can_sites[[49]]) %>% 
  compile_taxa(list.name = "WhitmoreFull") %>% 
  compile_downloads()

run_tf(Pollen, fossil = fossil_data[,11:ncol(fossil_data)], 
       climate = Climate,
       func = WA, col = 1, mono = TRUE)

```

Weighted Averaging results change, as expected.  The dataset is smaller overall, so there is higher total variance explained, and the threshold for significance is also higher.  $P_{jja}$ can explain 64% of the total variance in the fossil pollen dataset.  $T_{jja}$ can explain 62% of total variance.

#### WAPLS (Four components)

```{r WAPLS_sigtesting, cache=TRUE, results='asis', echo=FALSE, warning=FALSE}

run_tf(Pollen, fossil = fossil_data[,11:ncol(fossil_data)], 
       climate = Climate,
       func = WAPLS, col = 3) 

```

With WAPLS we se no significance for temperature variables, only $P_{jja}$ and $P_{ann}$, along with $E:PE$, which may be tied to the combination of seasonal and annual precipitation parameters.

#### MAT - ten closest

```{r MAT_sigtesting_fPine, cache=TRUE, results='asis', echo=FALSE, warning=FALSE}

run_tf(Pollen, fossil = fossil_data[,11:ncol(fossil_data)], 
       climate = Climate, 
       func = MAT, col = 2, k = 10) 

```

The randomization procedure appears to indicate that the variance explained by $P_{ann}$, $E:PE$ and $T_{jja}$ are all significant in this case.

## Reconstruction

Once we have validated the methods, we re-run the analysis using each of the three methods, across all the climate variables (just in case).

### Model Summary

Model support is highest for $P_{jja}$, with two of three models (WA, WAPLS) supporting it with *Pinus*, and all three supporting it without *Pinus*.  Annual precipitation is supported by the same number of models as $P_{jja}$, except that it is supported with *Pinus* for MAT, and not for WA (the reverse is true for $P_{jja}$). 

Winter precipitation ($P_{djf}$) is only supported in two models that exclude *Pinus*, WAPLS and MAT.  Summer temperature ($T_{jja}$) is supported with *Pinus* for WA and MAT, and for MAT without *Pinus*.  Annual temperature ($T_{ann}$) is only supported by MAT when *Pinus* is included.

```{r clim_reconst, cache=TRUE, results='asis', echo=FALSE, warning=FALSE}

# I'm getting a warning that some pollen_pct is showing zero dists, but I don't see them. . . 
if ("mat_reconst.RDS" %in% list.files("data/output")) {
  mat_reconst <- readRDS(file = 'data/output/mat_reconst.RDS')
} else {
  mat_reconst <- lapply(1:8, function(x) { predict(rioja::MAT(y = pollen_pct_p, 
                                                              x = clim[,x], 
                                                              k = 10, lean = FALSE),
                                                   newdata = orhid_pol, sse = TRUE) })
  saveRDS(mat_reconst, file = 'data/output/mat_reconst.RDS')
}
  
if ("wa_reconst.RDS" %in% list.files("data/output")) {
  wa_reconst <- readRDS(file = 'data/output/wa_reconst.RDS')
} else {
  wa_reconst <-  lapply(1:8, function(x) { predict(rioja::WA(y = pollen_pct_p, 
                                                              x = clim[,x], 
                                                              mono = TRUE, lean = FALSE),
                                                   newdata = orhid_pol, sse = TRUE) })
  saveRDS(wa_reconst, file = 'data/output/wa_reconst.RDS')
}

if ("wapls_reconst.RDS" %in% list.files("data/output")) {
  wapls_reconst <- readRDS(file = 'data/output/wapls_reconst.RDS')
} else {

  wapls_reconst <- lapply(1:8, function(x) { predict(rioja::WAPLS(y = pollen_pct_p, 
                                                                  x = clim[,x], 
                                                                  npls = 4, lean = FALSE),
                                                     newdata = orhid_pol, sse = TRUE) })
  saveRDS(wapls_reconst, file = 'data/output/wapls_reconst.RDS')
}

```

```{r plot_reconst, fig.width=8, fig.height=9, echo=FALSE}

get_clim <- lapply(1:8, function(x) { 
  data.frame(age = 1:nrow(wa_reconst[[x]]$fit),
             reconst = c(wa_reconst[[x]]$fit[,3],
                         wapls_reconst[[x]]$fit[,4],
                         mat_reconst[[x]]$fit[,1]),
             err     = c(wa_reconst[[x]]$SEP[,3],
                         wapls_reconst[[x]]$SEP[,4],
                         mat_reconst[[x]]$SEP[,1]),
             model   = rep(c("WA", "WAPLS", "MAT"), 
                           each = length(orhid_ages)),
             climate = colnames(clim)[x])}) %>% 
  do.call(rbind.data.frame,.)

ggplot(get_clim, aes(x = age, y = reconst)) + geom_line(aes(col = model)) +
  geom_ribbon(aes(ymin = reconst - err, ymax = reconst + err, group = model), alpha = 0.2) +
  facet_wrap(~climate, scales = 'free', ncol = 2) +
  xlab("Age - kyr BP") +
  ylab("Reconstructed Parameter")

```

# Saving to file

Ultimately, you would want to save values to file.  Your preference for the savefile structure will vary.  Here we are exporting two files, one with error and one with the raw reconstructions.  This implies a folder structure that I like, which is having a project `data` folder with both `input` and `output` sub-directories.  This helps keep your data files separated.  You might want to go further and add version numbers to the output files.  I'll leave that up to the user's discretion.

```r
write.csv(reshape2::dcast(get_clim, age ~ model + climate, value.var = "reconst"), 
          "data/output/clim_reconst.csv")
write.csv(reshape2::dcast(get_clim, age ~ model + climate, value.var = "err"), 
          "data/output/clim_err.csv")

```
